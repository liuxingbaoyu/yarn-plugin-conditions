/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin=(()=>{var te=Object.create,U=Object.defineProperty,ne=Object.defineProperties,oe=Object.getOwnPropertyDescriptor,ie=Object.getOwnPropertyDescriptors,re=Object.getOwnPropertyNames,I=Object.getOwnPropertySymbols,se=Object.getPrototypeOf,W=Object.prototype.hasOwnProperty,ae=Object.prototype.propertyIsEnumerable;var N=(t,e,n)=>e in t?U(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,E=(t,e)=>{for(var n in e||(e={}))W.call(e,n)&&N(t,n,e[n]);if(I)for(var n of I(e))ae.call(e,n)&&N(t,n,e[n]);return t},V=(t,e)=>ne(t,ie(e)),ce=t=>U(t,"__esModule",{value:!0});var u=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var le=(t,e)=>{for(var n in e)U(t,n,{get:e[n],enumerable:!0})},pe=(t,e,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of re(e))!W.call(t,o)&&o!=="default"&&U(t,o,{get:()=>e[o],enumerable:!(n=oe(e,o))||n.enumerable});return t},f=t=>pe(ce(U(t!=null?te(se(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var me={};le(me,{default:()=>fe});var Q=f(u("@yarnpkg/core"));var k=f(u("@yarnpkg/core"));function M(t){let e="condition:";if(!t.startsWith(e,0))throw new Error(`Expected 'condition:' at index 0 (${t})`);let n=e.length;a();let o=d(/[\w-]+/y);if(!o)throw new Error(`Expected an identifier at index ${n} (${t})`);a(),s("?"),a();let i=null;t[n]==="("?(i=m().trim()||null,a()):t[n]!==":"&&(i=P(":").trimRight()||null),s(":"),a();let r=null;n<t.length&&(t[n]==="("?(r=m().trim()||null,a()):t[n]!==":"&&(r=P("#").trimRight()||null));let c=null;if(n<t.length&&t[n]==="#"&&(n++,c=d(/\w+/y),a()),n!==t.length)throw new Error(`Unexpected '${t[n]}' at index ${n} (${t})`);return{test:o,consequent:i,alternate:r,hash:c};function s(l){if(t[n]!==l)throw new Error(`Expected '${l}' at index ${n} (${t})`);n++}function a(){d(/\s*/y)}function d(l){l.lastIndex=n;let p=l.exec(t);return p?(n+=p[0].length,p[0]):null}function P(l){let p=n;return n=t.indexOf(l,p),n===-1&&(n=t.length),t.slice(p,n)}function m(){s("(");let l=1,p="";for(;l;){if(n===t.length)throw new Error(`Expected ')' at index ${n} (${t})`);let D=t[n];D==="("&&l++,D===")"&&l--,(D!==")"||l>0)&&(p+=D),n++}return p}}var $=["dependencies","devDependencies","peerDependencies"],z=6;function h(t){return t.startsWith("condition:")}function A(t){try{return M(t)}catch(e){try{let{test:n,consequent:o,alternate:i}=k.structUtils.parseRange(t).params;return{test:n,consequent:o||null,alternate:i||null}}catch{throw e}}}function x(t){return A(t.range)}function b(t){return A(t.reference)}function de({test:t,consequent:e,alternate:n,hash:o}){return`condition:${t}?${e||""}:${n||""}#${o||""}`}function Y(t,{test:e,consequent:n,alternate:o,hash:i}){return k.structUtils.makeLocator(t,de({test:e,consequent:n,alternate:o,hash:i}))}function v(t,e,n,o,i){let r=k.structUtils.makeIdent(e.scope,`${e.name}-${n}-${i}`),c=t.configuration.get("defaultProtocol")+`${k.structUtils.stringifyIdent(e)}@${o}`;return k.structUtils.makeDescriptor(r,c)}function j(t,e,n,o){return k.hashUtils.makeHash(String(z),t,e||"-",n||"-",o?"1":"0").slice(0,6)}var L=f(u("@yarnpkg/core")),B={conditions:{description:"",type:L.SettingsType.MAP,valueDefinition:{description:"",type:L.SettingsType.SHAPE,properties:{source:{description:"",type:L.SettingsType.STRING,default:"env"},default:{description:"",type:L.SettingsType.BOOLEAN,default:!1}}}}};function H(t,e){if(!t.configuration.get("conditions").has(e))throw new Error(`Unknown condition: ${e}. You must add it to your .yarnrc.yml file.`)}function R(t,e){return H(t,e),t.configuration.get("conditions").get(e).get("default")}function q(t,e){var r;H(t,e);let n=t.configuration.get("conditions").get(e),o=n.get("source"),i=n.get("default");if(o!=="env")throw new Error("The only supported configuration source is 'env'");return(r=ue(process.env[e]))!=null?r:i}function ue(t){return t&&t!=="false"&&t!=="0"}var O=class{supportsDescriptor(e){return h(e.range)}supportsLocator(e){return h(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e,n){let{test:o,consequent:i,alternate:r}=x(e);return[i&&v(n.project,e,o,i,!0),r&&v(n.project,e,o,r,!1)].filter(Boolean)}async getCandidates(e,n,o){let{test:i,consequent:r,alternate:c}=x(e),s=j(i,r,c,R(o.project,i));return[Y(e,{test:i,consequent:r,alternate:c,hash:s})]}async getSatisfying(){return null}async resolve(e,n){let{test:o,consequent:i,alternate:r}=b(e),c=j(o,i,r,R(n.project,o)),s=i&&v(n.project,e,o,i,!0),a=r&&v(n.project,e,o,r,!1);return V(E({},e),{version:`0.0.0-condition-${c}`,languageName:n.project.configuration.get("defaultLanguageName"),linkType:Q.LinkType.HARD,dependencies:new Map([i&&[s.identHash,s],r&&[a.identHash,a]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null})}};var S=f(u("@yarnpkg/core"));var _=f(u("@yarnpkg/core")),y=f(u("@yarnpkg/fslib")),J=f(u("@yarnpkg/libzip")),K=15805116e5;async function G(t,e,n,o){let[i,r]=await Promise.all([y.xfs.mktempPromise(),(0,J.getLibzipPromise)()]),c=y.ppath.join(i,"condition.zip"),s=_.structUtils.getIdentVendorPath(t),a=new y.ZipFS(c,{libzip:r,create:!0,level:e.configuration.get("compressionLevel")});return await a.mkdirpPromise(s),await Promise.all([a.writeJsonPromise(y.ppath.join(s,"package.json"),n),a.writeFilePromise(y.ppath.join(s,"index.js"),o)]),await Promise.all(a.getAllFiles().map(d=>a.utimesPromise(d,K,K))),a}var F=class{supports(e){return h(e.reference)}getLocalPath(){return null}async fetch(e,n){let o=n.checksums.get(e.locatorHash)||null,[i,r,c]=await n.cache.fetchPackageFromCache(e,o,{onHit:()=>n.report.reportCacheHit(e),onMiss:()=>n.report.reportCacheMiss(e,`${S.structUtils.prettyLocator(n.project.configuration,e)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.generateConditionPackage(e,n),skipIntegrityCheck:n.skipIntegrityCheck});return{packageFs:i,releaseFs:r,prefixPath:S.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:c}}async generateConditionPackage(e,n){let{test:o,consequent:i,alternate:r}=b(e),c=R(n.project,o),s=j(o,i,r,c),a=(m,l)=>{if(m==null)return{dependency:null,require:"null"};let p=v(n.project,e,o,m,l),D=S.structUtils.stringifyIdent(p);return{dependency:{[D]:p.range},require:`require(${JSON.stringify(D)})`}},d=a(i,!0),P=a(r,!1);return G(e,n.project,{version:`0.0.0-condition-${s}`,dependencies:E(E({},d.dependency),P.dependency)},`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"
function bool(value) {
  if (value == null) return ${c};
  return value && value !== "false" && value !== "0";
}
module.exports = bool(process.env[${JSON.stringify(o)}])
  ? ${d.require}
  : ${P.require};
`)}};var T=f(u("@yarnpkg/core"));async function Z(t,e){var i;let{project:n}=t,o=!1;for(let r of $){let c=t.manifest.getForScope(r).values();for(let s of c){if(!h(s.range))continue;let{test:a,consequent:d,alternate:P}=x(s),m=q(n,a)?d:P,l=T.structUtils.stringifyIdent(s),p=r==="dependencies"&&!e.dependencies[l]&&((i=e.optionalDependencies)==null?void 0:i[l])?"optionalDependencies":r;m?(e[p][l]=m,t.manifest.raw[p][l]=m,t.manifest[r].set(s.identHash,T.structUtils.makeDescriptor(s,m))):(delete e[p][l],delete t.manifest.raw[p][l],t.manifest[r].delete(s.identHash)),o=!0}}o&&await t.project.configuration.triggerHook(r=>r.beforeWorkspacePacking,t,e)}var g=f(u("@yarnpkg/core")),X=f(u("@yarnpkg/cli")),w=f(u("clipanion")),ee=f(u("typanion"));var C=class extends X.BaseCommand{constructor(){super(...arguments);this.condition=w.Option.String({required:!0});this.true=w.Option.Boolean("--true",!1);this.false=w.Option.Boolean("--false",!1)}async execute(){let{project:e,workspace:n,cache:o,configuration:i}=await this.getRoot();H(e,this.condition);let r=this.false?!1:this.true?!0:q(e,this.condition);for(let s of this.nestedWorkspaces(n,e))this.materializeCondition(r,s);let c=await g.StreamReport.start({configuration:i,stdout:this.context.stdout,includeLogs:!0},async s=>{await e.resolveEverything({cache:o,report:s})});if(c.hasErrors())return c.exitCode();await e.persist()}*nestedWorkspaces(e,n){yield e;for(let o of e.workspacesCwds){let i=n.workspacesByCwd.get(o);i&&(yield*this.nestedWorkspaces(i,n))}}materializeCondition(e,n){for(let o of $){let i=n.manifest.getForScope(o).values();for(let r of i){if(!h(r.range))continue;let{test:c,consequent:s,alternate:a}=x(r);if(c!==this.condition)continue;let d=e?s:a;d?n.manifest[o].set(r.identHash,g.structUtils.makeDescriptor(r,d)):n.manifest[o].delete(r.identHash)}}}async getRoot(){let e=await g.Configuration.find(this.context.cwd,this.context.plugins),[{project:n,workspace:o},i]=await Promise.all([g.Project.find(e,this.context.cwd),g.Cache.find(e,{immutable:!0})]);return{configuration:e,project:n,workspace:o,cache:i}}};C.paths=[["condition","materialize"]],C.usage=w.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "}),C.schema=[ee.hasMutuallyExclusiveKeys(["true","false"])];var fe={configuration:B,commands:[C],fetchers:[F],resolvers:[O],hooks:{beforeWorkspacePacking:Z}};return me;})();
return plugin;
}
};
