/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin=(()=>{var oe=Object.create,E=Object.defineProperty,ie=Object.defineProperties,se=Object.getOwnPropertyDescriptor,ce=Object.getOwnPropertyDescriptors,ue=Object.getOwnPropertyNames,T=Object.getOwnPropertySymbols,le=Object.getPrototypeOf,V=Object.prototype.hasOwnProperty,de=Object.prototype.propertyIsEnumerable;var H=(e,n,t)=>n in e?E(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,w=(e,n)=>{for(var t in n||(n={}))V.call(n,t)&&H(e,t,n[t]);if(T)for(var t of T(n))de.call(n,t)&&H(e,t,n[t]);return e},M=(e,n)=>ie(e,ce(n)),fe=e=>E(e,"__esModule",{value:!0});var g=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var ae=(e,n)=>{for(var t in n)E(e,t,{get:n[t],enumerable:!0})},pe=(e,n,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let r of ue(n))!V.call(e,r)&&r!=="default"&&E(e,r,{get:()=>n[r],enumerable:!(t=se(n,r))||t.enumerable});return e},h=e=>pe(fe(E(e!=null?oe(le(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var je={};ae(je,{default:()=>Oe});var Y=h(g("@yarnpkg/core"));var b=h(g("@yarnpkg/core"));function W(e){let n="condition:";if(!e.startsWith(n,0))throw new Error(`Expected 'condition:' at index 0 (${e})`);let t=n.length;u();let r=d(/[\w-]+/y);if(!r)throw new Error(`Expected an identifier at index ${t} (${e})`);u(),c("?"),u();let o=null;e[t]==="("?(o=p().trim()||null,u()):e[t]!==":"&&(o=a(":").trimRight()||null),c(":"),u();let i=null;t<e.length&&(e[t]==="("?(i=p().trim()||null,u()):e[t]!==":"&&(i=a("#").trimRight()||null));let s=null;if(t<e.length&&e[t]==="#"&&(t++,s=d(/\w+/y),u()),t!==e.length)throw new Error(`Unexpected '${e[t]}' at index ${t} (${e})`);return{test:r,consequent:o,alternate:i,hash:s};function c(l){if(e[t]!==l)throw new Error(`Expected '${l}' at index ${t} (${e})`);t++}function u(){d(/\s*/y)}function d(l){l.lastIndex=t;let f=l.exec(e);return f?(t+=f[0].length,f[0]):null}function a(l){let f=t;return t=e.indexOf(l,f),t===-1&&(t=e.length),e.slice(f,t)}function p(){c("(");let l=1,f="";for(;l;){if(t===e.length)throw new Error(`Expected ')' at index ${t} (${e})`);let v=e[t];v==="("&&l++,v===")"&&l--,(v!==")"||l>0)&&(f+=v),t++}return f}}var S=["dependencies","devDependencies","peerDependencies"],z=6;function y(e){return e.startsWith("condition:")}function B(e){try{return W(e)}catch(n){try{let{test:t,consequent:r,alternate:o}=b.structUtils.parseRange(e).params;return{test:t,consequent:r||null,alternate:o||null}}catch{throw n}}}function $(e){return B(e.range)}function R(e){return B(e.reference)}function ge({test:e,consequent:n,alternate:t,hash:r}){return`condition:${e}?${n||""}:${t||""}#${r||""}`}function J(e,{test:n,consequent:t,alternate:r,hash:o}){return b.structUtils.makeLocator(e,ge({test:n,consequent:t,alternate:r,hash:o}))}function x(e,n,t,r,o){let i=b.structUtils.makeIdent(n.scope,`${n.name}-${t}-${o}`),s=e.configuration.get("defaultProtocol")+`${b.structUtils.stringifyIdent(n)}@${r}`;return b.structUtils.makeDescriptor(i,s)}function P(e,n,t,r){return b.hashUtils.makeHash(String(z),e,n||"-",t||"-",r?"1":"0").slice(0,6)}var U=h(g("@yarnpkg/core")),K={conditions:{description:"",type:U.SettingsType.MAP,valueDefinition:{description:"",type:U.SettingsType.SHAPE,properties:{source:{description:"",type:U.SettingsType.STRING,default:"env"},default:{description:"",type:U.SettingsType.BOOLEAN,default:!1}}}}};function A(e,n){if(!e.configuration.get("conditions").has(n))throw new Error(`Unknown condition: ${n}. You must add it to your .yarnrc.yml file.`)}function D(e,n){return A(e,n),e.configuration.get("conditions").get(n).get("default")}function C(e,n){var i;A(e,n);let t=e.configuration.get("conditions").get(n),r=t.get("source"),o=t.get("default");if(r!=="env")throw new Error("The only supported configuration source is 'env'");return(i=he(process.env[n]))!=null?i:o}function he(e){return e&&e!=="false"&&e!=="0"}var I=class{supportsDescriptor(n){return y(n.range)}supportsLocator(n){return y(n.reference)}shouldPersistResolution(){return!1}bindDescriptor(n){return n}getResolutionDependencies(n,t){let{test:r,consequent:o,alternate:i}=$(n);return[o&&x(t.project,n,r,o,!0),i&&x(t.project,n,r,i,!1)].filter(Boolean)}async getCandidates(n,t,r){let{test:o,consequent:i,alternate:s}=$(n),c=P(o,i,s,D(r.project,o));return[J(n,{test:o,consequent:i,alternate:s,hash:c})]}async getSatisfying(){return null}async resolve(n,t){let{test:r,consequent:o,alternate:i}=R(n),s=P(r,o,i,D(t.project,r)),c=o&&x(t.project,n,r,o,!0),u=i&&x(t.project,n,r,i,!1);return M(w({},n),{version:`0.0.0-condition-${s}`,languageName:t.project.configuration.get("defaultLanguageName"),linkType:Y.LinkType.HARD,dependencies:new Map([o&&[c.identHash,c],i&&[u.identHash,u]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null})}};var _=h(g("@yarnpkg/core"));var Z=h(g("@yarnpkg/core")),k=h(g("@yarnpkg/fslib")),Q=h(g("@yarnpkg/libzip")),G=15805116e5;async function X(e,n,t,r){let[o,i]=await Promise.all([k.xfs.mktempPromise(),(0,Q.getLibzipPromise)()]),s=k.ppath.join(o,"condition.zip"),c=Z.structUtils.getIdentVendorPath(e),u=new k.ZipFS(s,{libzip:i,create:!0,level:n.configuration.get("compressionLevel")});return await u.mkdirpPromise(c),await Promise.all([u.writeJsonPromise(k.ppath.join(c,"package.json"),t),u.writeFilePromise(k.ppath.join(c,"index.js"),r)]),await Promise.all(u.getAllFiles().map(d=>u.utimesPromise(d,G,G))),u}var q=class{supports(n){return y(n.reference)}getLocalPath(){return null}async fetch(n,t){let r=t.checksums.get(n.locatorHash)||null,[o,i,s]=await t.cache.fetchPackageFromCache(n,r,{onHit:()=>t.report.reportCacheHit(n),onMiss:()=>t.report.reportCacheMiss(n,`${_.structUtils.prettyLocator(t.project.configuration,n)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.generateConditionPackage(n,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:o,releaseFs:i,prefixPath:_.structUtils.getIdentVendorPath(n),localPath:this.getLocalPath(),checksum:s}}async generateConditionPackage(n,t){let{test:r,consequent:o,alternate:i}=R(n),s=D(t.project,r),c=P(r,o,i,s),u=(p,l)=>{if(p==null)return{dependency:null,require:"null"};let f=x(t.project,n,r,p,l),v=_.structUtils.stringifyIdent(f);return{dependency:{[v]:f.range},require:`require(${JSON.stringify(v)})`}},d=u(o,!0),a=u(i,!1);return X(n,t.project,{version:`0.0.0-condition-${c}`,dependencies:w(w({},d.dependency),a.dependency)},`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"
function bool(value) {
  if (value == null) return ${s};
  return value && value !== "false" && value !== "0";
}
module.exports = bool(process.env[${JSON.stringify(r)}])
  ? ${d.require}
  : ${a.require};
`)}};var F=h(g("@yarnpkg/core"));var me=Function.call.bind(Object.prototype.hasOwnProperty);async function ee(e,n){var o;let{project:t}=e,r=!1;for(let i of S){let s=e.manifest.getForScope(i).values();for(let c of s){if(!y(c.range))continue;let{test:u,consequent:d,alternate:a}=$(c),p=C(t,u)?d:a,l=F.structUtils.stringifyIdent(c),f=i==="dependencies"&&!n.dependencies[l]&&((o=n.optionalDependencies)==null?void 0:o[l])?"optionalDependencies":i;p?(n[f][l]=p,e.manifest.raw[f][l]=p,e.manifest[i].set(c.identHash,F.structUtils.makeDescriptor(c,p))):(delete n[f][l],delete e.manifest.raw[f][l],e.manifest[i].delete(c.identHash)),r=!0}}if(me(n,"conditions")){r=!0;let i=n.conditions;for(let[s,[c,u]]of Object.entries(i)){let d=C(t,s)?c:u;if(d)for(let[a,p]of Object.entries(d))p===null?delete n[a]:n[a]=p}delete n.conditions}r&&await e.project.configuration.triggerHook(i=>i.beforeWorkspacePacking,e,n)}var m=h(g("@yarnpkg/core")),te=h(g("@yarnpkg/cli")),O=h(g("clipanion"));function N(e){return e===null?"null":e===void 0?"undefined":e===""?"an empty string":typeof e=="symbol"?`<${e.toString()}>`:Array.isArray(e)?"an array":JSON.stringify(e)}function ye(e,n){if(e.length===0)return"nothing";if(e.length===1)return N(e[0]);let t=e.slice(0,-1),r=e[e.length-1],o=e.length>2?`, ${n} `:` ${n} `;return`${t.map(i=>N(i)).join(", ")}${o}${N(r)}`}function be({errors:e,p:n}={},t){return e==null||e.push(`${n!=null?n:"."}: ${t}`),!1}var cn=new Map([["true",!0],["True",!0],["1",!0],[1,!0],["false",!1],["False",!1],["0",!1],[0,!1]]);function ke(e){return()=>e}function ve({test:e}){return ke(e)()}var $e={missing:(e,n)=>e.has(n),undefined:(e,n,t)=>e.has(n)&&typeof t[n]!="undefined",nil:(e,n,t)=>e.has(n)&&t[n]!=null,falsy:(e,n,t)=>e.has(n)&&!!t[n]};function ne(e,n){var t;let r=new Set(e),o=$e[(t=n==null?void 0:n.missingIf)!==null&&t!==void 0?t:"missing"];return ve({test:(i,s)=>{let c=new Set(Object.keys(i)),u=[];for(let d of r)o(c,d,i)&&u.push(d);return u.length>1?be(s,`Mutually exclusive properties ${ye(u,"and")}`):!0}})}var L;(function(e){e.Forbids="Forbids",e.Requires="Requires"})(L||(L={}));var un={[L.Forbids]:{expect:!1,message:"forbids using"},[L.Requires]:{expect:!0,message:"requires using"}};var xe=Function.call.bind(Object.prototype.hasOwnProperty),re=(e,n,...t)=>xe(e,n)&&(t.length===0||re(e[n],...t)),j=class extends te.BaseCommand{constructor(){super(...arguments);this.condition=O.Option.String({required:!0});this.true=O.Option.Boolean("--true",!1);this.false=O.Option.Boolean("--false",!1)}async execute(){let{project:n,workspace:t,cache:r,configuration:o}=await this.getRoot();A(n,this.condition);let i=this.false?!1:this.true?!0:C(n,this.condition);for(let c of this.nestedWorkspaces(t,n))this.materializeCondition(i,c);let s=await m.StreamReport.start({configuration:o,stdout:this.context.stdout,includeLogs:!0},async c=>{await n.resolveEverything({cache:r,report:c})});if(s.hasErrors())return s.exitCode();await n.persist()}*nestedWorkspaces(n,t){yield n;for(let r of n.workspacesCwds){let o=t.workspacesByCwd.get(r);o&&(yield*this.nestedWorkspaces(o,t))}}materializeCondition(n,t){for(let o of S){let i=t.manifest.getForScope(o).values();for(let s of i){if(!y(s.range))continue;let{test:c,consequent:u,alternate:d}=$(s);if(c!==this.condition)continue;let a=n?u:d;a?t.manifest[o].set(s.identHash,m.structUtils.makeDescriptor(s,a)):t.manifest[o].delete(s.identHash)}}let r=t.manifest.raw;if(re(r,"conditions",this.condition)){let[o,i]=r.conditions[this.condition],s=n?o:i;if(s)for(let[c,u]of Object.entries(s))u===null?delete r[c]:r[c]=u;Object.keys(r.conditions).length===1?delete r.conditions:delete r.conditions[this.condition]}}async getRoot(){let n=await m.Configuration.find(this.context.cwd,this.context.plugins),[{project:t,workspace:r},o]=await Promise.all([m.Project.find(n,this.context.cwd),m.Cache.find(n,{immutable:!0})]);return{configuration:n,project:t,workspace:r,cache:o}}};j.paths=[["condition","materialize"]],j.usage=O.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "}),j.schema=[ne(["true","false"],{missingIf:"falsy"})];var Oe={configuration:K,commands:[j],fetchers:[q],resolvers:[I],hooks:{beforeWorkspacePacking:ee}};return je;})();
return plugin;
}
};
